<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>apertium-kaz</title>
<!-- 2018-09-13 Thu 04:28 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Илнар Сәлимҗанов" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">apertium-kaz</h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <code>APERTIUM-KAZ</code>: A MORPHOLOGICAL TRANSDUCER AND DISAMBIGUATOR FOR KAZAKH</h2>
<div class="outline-text-2" id="text-1">
<p>
WARNING: this is an early draft.
</p>

<p>
What follows is the documentation for <code>apertium-kaz</code> &#x2013; a morphological
transducer and disambiguator for Kazakh. First draft of this documentation was
written, or, rather, assembled from various writings from <a href="https://wiki.apertium.org">Apertium's wiki</a> and
then extended with more details by selimcan on September 2018 for members of
the `Deep Learning for Sequential Models in Natural Language Processing with
Applications to Kazakh' (dlsmnlpak) research group at Nazarbayev University and
elsewhere. That being said, I hope that it will be useful for anyone who uses
apertium-kaz and maybe wants to extend it with more stems. One of the goals of
the dlsmnlpak research project is to develop an annotated corpus of Kazakh, and
extend apertium-kaz with more stems and probabilistic guessing/tagging
capabilities. Most of the things said in this guide might be applicable to
Apertium's transducers for other Turkic languages as well.
</p>

<p>
-&#x2014;
</p>

<p>
<b>Apertium-kaz</b> is a morphological transducer and disambiguator for Kazakh,
currently under development. It is intended to be compatible with transducers
for other Turkic languages so that they can be translated between. It's used in
the following language pairs:
</p>

<ul class="org-ul">
<li>Kazakh and Tatar
</li>
<li>English and Kazakh
</li>
<li>Kyrgyz and Kazakh
</li>
<li>Kazakh and Karakalpak
</li>
<li>Khalkha and Kazakh
</li>
<li>Kazakh and Russian
</li>
</ul>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Installation</h3>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Usage</h3>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Annotating texts using <code>apertium-kaz</code> and extending it with more stems while doing so</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Imagine the following scenario: a linguist is annotating a Kazakh text with
morphological information, taking the output of <code>kaz-morph</code> or <code>kaz-tagger</code> as
a starting point. Since the coverage of <code>apertium-kaz</code> at the time of this
writing (September 2018) is about 95%, #+BEGIN<sub>COMMENT</sub> TODO measure this
automatically and put the result here #+END<sub>COMMENT</sub> it is reasonable to assume
that, in the text that she is annotating, the linguist will encounter stems
unrecognized by the transducer.
</p>

<p>
Each stem in <code>apertium-kaz.kaz.lexc</code> &#x2013; the lexicon of the transducer &#x2013; can be
followed by one ore more affixes of Kazakh, and thus cover many wordforms. Thus
when annotating a text with morphological tags, it is wise to add missing stems
to the lexicon frequently, re-compile <code>apertium-kaz</code>
</p>

<p>
The most effective way of working is arguably the following way of working in
`layers':
</p>

<ul class="org-ul">
<li>pass the text that you want to annotate through the <code>kaz-tagger</code> mode
</li>
<li>read the output from the beginning
</li>
<li>for each unrecognized wordform:
<ul class="org-ul">
<li>identify its stem, following the information on that below
</li>
<li>try to analyse the stem: <code>echo "stem" | apertium -d . kaz-morph</code>
</li>
<li>if success: add the unrec. wordform to the end of <code>apertium-kaz.kaz.lexc</code>
    this way: =wordform
</li>
<li>else: add stem to <code>apertium-kaz.kaz.lexc</code> this way: =stem:stem LEXICON ; !
"english gloss"=, where you choose lexicon following the guidelines below
</li>
<li>recompile <code>apertium-kaz</code>
</li>
<li>pass the rest of the text you're annotating through the <code>kaz-tagger</code> mode
</li>
<li>make sure that the wordform is correctly analysed now
</li>
<li>repeat for the above steps for the rest of the text
</li>
</ul>
</li>
<li>once there are no unrecognized wordforms, start selecting the correct
analysis, if there are multiple. That is, filling in the third column of the
spreadsheet.
</li>
<li>if the input wordform is misspelled, do not correct it in place, but add the
sixth column in that row, in which give the properly spelled form of the
word. Why? Misspellings info is quite valuable info, which will alllow us to
do automatic spelling correction and thus making <code>apertium-kaz</code> more robust.
</li>
<li>add the resulting file to <code>apertium-kaz/corpus</code>, commit and push
</li>
</ul>

<p>
TODO Later there will be a program/Racket-based programming language ( which we
will call Apertium#), which, given some free-form text, does some of the above
and calculates probabilities automatically, under the hood,.
</p>

<p>
What does this output format give us?
</p>

<ul class="org-ul">
<li>All information potentially useful for statistical training +
meta-information (license, source, genre, year etc) in one place.
</li>
<li>Machine-readable.
</li>
<li>Spreadsheet friendly = easy &amp; fast to edit.
</li>
<li>Close/equivalent to the format used in NoSketchEngine and other corpus
processing tools, thus less overhead with converting etc.
</li>

<li>getting to 100% coverage;
</li>
</ul>
<p>
One of the goals <code>=</code> Guidelines for adding stems <code>=</code>
</p>

<p>
<code>==</code> An overview of the process <code>==</code>
</p>

<p>
If you see that a wordform is not supported by apertium-kaz and you want to add it, you have to figure out three things:
</p>

<p>
Here is an example of a word already in the apertium-kaz.kaz.lexc file:
</p>

<p>
&lt;pre&gt;
кітап:кітап N1 ; ! "book"
&lt;/pre&gt;
</p>

<p>
As in this example, in most cases, the left hand-side and the right-hand side of the entry are the same. The left-hand side is the underlying form, the right-hand is the surface form. Continuation lexicon in this example is N1. What comes after the exclamation mark '!' are comments. Glosses are a good thing to have, but technically they are only a comment, and thus optional.
</p>

<p>
Here is an example where the left and right hand sides are not the same:
</p>

<p>
&lt;pre&gt;
күн% тәртібі:күн% тәртіп N-COMPOUND-PX ; ! ""
&lt;/pre&gt;
</p>

<p>
This has been implemented in that way so that forms like "күн тәртіптері" can also be analysed as forms of the word "күн тәртібі".
</p>

<p>
The example above also shows that spaces in a word have to be escaped with %. So is the hyphen sign:
</p>

<p>
&lt;pre&gt;
мән%-жай:мән%-жай N1 ; ! ""
&lt;/pre&gt;
</p>

<p>
<code>==</code> General <code>==</code>
</p>

<ul class="org-ul">
<li>Before adding a stem, be sure it does not already exist in lexc. A good way to do that is to look up stem(s) you want to add with &lt;code&gt;lt-proc kaz.automorf.bin&lt;/code&gt;. In some cases, you'll see that the stem isn't analysed at all:
</li>
</ul>

<p>
^foo/*foo$
</p>

<p>
In some cases, it will be analysed, but as something else than what you want to add it as:
</p>

<p>
^Жол/жол&lt;adj&gt;$ ^жөндеуші/жөнде&lt;v&gt;&lt;tv&gt;&lt;gpr<sub>pot</sub>&gt;\(^./.<sent>\)
</p>

<p>
(assuming that you want to add "Жол жөндеуші as a company name, which it happens to be).
</p>

<p>
Another, probably more relevant example:
</p>

<p>
&lt;pre&gt;
apertium-kaz$ echo "қабылдау" | apertium -d . kaz-tagger 
^қабылдау/қабылда&lt;v&gt;&lt;tv&gt;&lt;ger&gt;&lt;nom&gt;\(^./.<sent>\)
&lt;/pre&gt;
</p>

<p>
(supposing that some other forms of the word, say with case affixes, like e.g. "қабылдауды" weren't analysed (see the next paragraph) and thus you looked up қабылдау in &lt;code&gt;kaz.autogen.bin&lt;/code&gt;). Looking the <b>stem</b> up (note: not the surface form, the stem) with the &lt;code&gt;lt-proc kaz.autogen.bin&lt;/code&gt; command before adding it to the lexc file gives you a chance to save some work and to avoid addiing the same thing twice.
</p>

<p>
In the third case, you will see that the stem is already there, is linked to the right lexicon, but some surface forms of the word are not analysed. This means that either there is a problem with the phonology part, or you've discovered some affix currently not supported by apertium-kaz. Both issues have to be documented/reported (the simplest way would be just to add an 'ISSUES' file to apertium-kaz and commit it).
</p>

<ul class="org-ul">
<li>Provide a commit message saying what you did.  At a bare minimum, "adding more stems" is okay, but "a" or "ф" is not.  Try to be more informative though; e.g. "added stems from story, mostly NP-TOP and NP-ANT" or similar.
</li>
<li>Many stems exhibit a voicing alternation like п/б, к/г, қ/ғ.  This is processed automatically by twol, but these stems ''must'' be added with the ''voiceless'' consonant (п, к, қ), e.g &lt;code&gt;тақ:тақ V-TV ;&lt;/code&gt;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Stems from Russian that end with one of the voiced consonants (б, г), such as &lt;code&gt;геолог&lt;/code&gt; should be entered as spelled, but should be put in the right category for foreign words (e.g., if a noun, then &lt;code&gt;N5&lt;/code&gt;).</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>Words that have an inserted ‹ы› or ‹і› in some forms should get &lt;code&gt;%{y%}&lt;/code&gt; in that spot on the right side, e.g. &lt;code&gt;орын:ор%{y%}н N1 ;&lt;/code&gt;.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Words that are commonly written in both forms (e.g., орнында and орынында) need special treatment: add &lt;code&gt;! Dir/LR&lt;/code&gt; after the form that should not be generated (i.e., the form that is the non-normative version), and add &lt;code&gt;! Err/Orth&lt;/code&gt; after it too if it should be considered a spelling mistake.</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>Any changes to continuation classes should be discussed on the apertium-turkic mailing list.
</li>
</ul>

<p>
Most likely, a word not covered by apertium-kaz already will be an open class word. Below are some comments on the open-class word lexicons.
</p>

<p>
<code>==</code> Verbs <code>==</code>
</p>
<ul class="org-ul">
<li>Categorise correctly according to IV or TV status:
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> IV = intransitive verbs; TV = transitive verbs</h3>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> If the verb can take a direct object with -НЫ, then it's not IV; otherwise it is TV</h3>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> For phrasal verbs (e.g,. "қабыл ал", "пайда бол", "мойынға ал"), do not categorise it according to its elements; instead treat it as a single verb (TV, IV, TV).</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>There should be no infinitival final -у or -ю.  It is best to take the part of the verb before -GAн or -DI in those forms.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Infinitives ending in -ю should end in ‹й› instead, e.g ‹сүю› should be entered as &lt;code&gt;сүй&lt;/code&gt;</h3>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Some verbs have a "hidden" ‹ы› or ‹і› under the ‹у›, for example &lt;code&gt;ері&lt;/code&gt;, &lt;code&gt;аршы&lt;/code&gt;, &lt;code&gt;аңды&lt;/code&gt;, etc.  These verb stems should be added ''with'' the ‹ы› or ‹і›.</h3>
</div>
<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> Of course, verbs with ‹у› in the stem should keep the ‹у›, like &lt;code&gt;жу&lt;/code&gt;, &lt;code&gt;қу&lt;/code&gt;, &lt;code&gt;жау&lt;/code&gt;, etc.</h3>
<div class="outline-text-3" id="text-1-11">
<ul class="org-ul">
<li>Do not add passive or cooperative forms of verb stems (e.g., ‹тартыл› is passive of ‹тарт›, and ‹тартыс› is cooperative) unless absolutely needed for translation.  In this case, put &lt;code&gt;! Use/MT ! Der/Pass&lt;/code&gt; or &lt;code&gt;! Use/MT ! Der/Coop&lt;/code&gt; after the entry, respectively.
</li>
<li>If you add a causative form of a verb (e.g., ‹отырғыз› is causative of ‹отыр›), put &lt;code&gt;! Der/Caus&lt;/code&gt; after it.
</li>
</ul>

<p>
<code>==</code> Nouns <code>==</code>
</p>
<ul class="org-ul">
<li>Some nouns end in ‹ә›, and have interesting or inconsistent-looking phonology, like &lt;code&gt;күнә&lt;/code&gt;, &lt;code&gt;кінә&lt;/code&gt;.  These should be added with the right side missing its ‹ә› and in the class N1-Ә.  E.g., &lt;code&gt;күнә:күн N1-Ә ;&lt;/code&gt;
</li>
<li>Nouns from Russian should be classified as &lt;code&gt;N5&lt;/code&gt;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> ''especially'' if the last vowel is ‹и› or ‹у›</h3>
</div>
<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> ''especially'' if they end with a consonant that would normally be voiced before a vowel-initial suffix in Kazakh words (п, к)</h3>
<div class="outline-text-3" id="text-1-13">
<ul class="org-ul">
<li>Nouns that are compounds ending in a possessive form (like ‹ауа райы›) should be categorised into the &lt;code&gt;N-COMPOUND-PX&lt;/code&gt; category and entered without the possessive ending on the right side, e.g. &lt;code&gt;ауа% райы:ауа% рай N-COMPOUND-PX ; ! "weather,climate"&lt;/code&gt;
</li>
<li>If you're adding a noun that can also be used as an adjective, think whether it's actually an adjective or actually a noun and add it to the right category.  You'll want to subcategorise it correctly so that e.g. if it's a noun it can also take the {{tag|attr}} tag.
</li>
</ul>

<p>
<code>==</code> Adjectives <code>==</code>
</p>
<ul class="org-ul">
<li>The basic categorisation of adjectives depends on whether it takes comparative morphology (-ЫрАҚ), can be substantivised (acts like a noun), and/or can be adverbialised (acts like an adverb).  Be sure to put the adjective in the right category according what those categories allow.
</li>

<li>If you're adding an adjective that can also be used as a noun, think whether it's actually an adjective or actually a noun and add it to the right category.  You'll want to subcategorise it correctly so that e.g. if it's an adjective it can also take the {{tag|subst}} tag.
</li>
</ul>

<p>
<code>==</code> Adverbs <code>==</code>
</p>
<ul class="org-ul">
<li>If you want to add an adverb, first think whether the word is really an adjective that can be used like an adverb.  If this is the case, then add it as an adjective in the appropriate adjective class that can take the {{tag|advl}} tag.  In the bidix, you'll want to translate the {{tag|adj}} and the {{tag|adj}}{{tag|advl}} forms differently.
</li>
</ul>

<p>
<code>=</code> Additional tags <code>=</code>
</p>

<p>
In a .lexc file, after the '!' you will also see &lt;code&gt;Dir/LR&lt;/code&gt;, &lt;code&gt;Dir/RL&lt;/code&gt;, &lt;code&gt;Err/Orth&lt;/code&gt; and &lt;code&gt;Use/MT&lt;/code&gt; comments. The meaning of them is as follows:
</p>

<p>
'''&lt;code&gt;Dir/LR&lt;/code&gt;''' means: analyse this surface form, but don't generate it. Here is a good example:
</p>

<p>
&lt;pre&gt;
сұхбат:сұқбат N1 ; ! "conversation/interview" Dir/LR
сұхбат:сұхбат N1 ; ! "conversation/interview"
&lt;/pre&gt;
</p>

<p>
In other words, &lt;code&gt;Dir/LR&lt;/code&gt; marks alternative spellings of a word. If the alternative spelling isn't just alternative, but actually erroneous (but occurs quite commonly so that you want to support it), it is marked with the '''&lt;code&gt;Err/Orth&lt;/code&gt;''' tag:
</p>

<p>
&lt;pre&gt;
орын:ор%{y%}н N1 ; ! "place,seat"
орын:орын N1 ; ! "place,seat"  ! Dir/LR ! Err/Orth
&lt;/pre&gt;
</p>

<p>
"Орыны" for example, is considered erroneous spelling of "орын&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;". Such markings will allow us to produce better spell checkers.
</p>

<p>
In the examples above, if you don't mark either of the stems with &lt;code&gt;Dir/LR&lt;/code&gt;, then the Kazakh generator, (if we personify it a bit) given a string like "<sup>сұхбат</sup>&lt;n&gt;&lt;nom&gt;$ for input, won't know which surface form to choose and will output both, separated with a slash: сұхбат/сұқбат.
</p>

<p>
As the name suggests, '''&lt;code&gt;Dir/RL&lt;/code&gt;''' has the meaning opposite to &lt;code&gt;Dir/LR&lt;/code&gt;: 'generate this surface form, but do not analyse it'. You won't see it much in a lexc file and almost certainly won't need to mark a stem you add as Dir/RL. Here is an example though: 
</p>

<p>
&lt;pre&gt;
да:%~да CC ; ! "also" Dir/RL
&lt;/pre&gt;
</p>

<p>
The conjunction ^да&lt;cnj$ gets generated as "~да". This is necessary for a somewhat hacky way of handling the vowel harmony (read: making sure that the "да" gets rendered as "де" when the preceding word has front vowels) in cases where the standard way of handling the vowel harmony (read: <i>twol</i>) fails because the preceding word is unknown. 
</p>

<p>
'''Use/MT''' (at least, in its original usage) marks (compound) words which are needed for translation, but probably shouldn't be in a "vanilla" Kazakh transducer:
</p>

<p>
&lt;pre&gt;
қайда% болса% сонда:қайда% болса% сонда PRON-IND ; ! "anywhere" Use/MT
&lt;/pre&gt;
</p>

<p>
It has been also used to mark words which the person who added them wasn't sure how to classify. Such words will be reviewed later.
</p>

<p>
<code>=</code> Full inventory of lexicons the stems can be linked to <code>=</code>
</p>

<p>
It is useful to distinguish two classes of lexicons:
</p>
<p>
Here is an attempt to document the lexicons of the second kind found in the &lt;code&gt;apertium-kaz.kaz.lexc&lt;/code&gt; file (so that: 1. people can add stems to a lexc file without having to read the lexc file itself 2. we can re-evaluate our decisions):
</p>

<p>
Nouns:
</p>
</div>
</div>
<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> N1</h3>
</div>
<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15"><span class="section-number-3">1.15</span> N-COMPOUND-PX</h3>
</div>
<div id="outline-container-sec-1-16" class="outline-3">
<h3 id="sec-1-16"><span class="section-number-3">1.16</span> N5</h3>
</div>
<div id="outline-container-sec-1-17" class="outline-3">
<h3 id="sec-1-17"><span class="section-number-3">1.17</span> N1-ABBR</h3>
</div>
<div id="outline-container-sec-1-18" class="outline-3">
<h3 id="sec-1-18"><span class="section-number-3">1.18</span> N-INFL-INKI</h3>
<div class="outline-text-3" id="text-1-18">
<p>
Proper nouns:
</p>
<ul class="org-ul">
<li>NP-ANT-F: feminine anthroponyms
</li>
<li>NP-ANT-M: masculine anthroponyms
</li>
<li>NP-COG-OB: family names ending with -ов or -ев
</li>
<li>NP-COG-IN: family names ending with -ин
</li>
<li>NP-COG-M: family name not ending with -ов, -ев or -in; masculine. Example: Галицкий
</li>
<li>NP-COG-F: family name not ending with -ов, -ев or -in; feminine. Example: Толстая
</li>
<li>NP-COG-MF: family names not ending with -ов, -ев or -in which are both masculine and feminine: 
</li>
<li>NP-PAT-VICH: patronyms ending with -вич (and thus which can also take the -вна ending): &lt;code&gt;Васильевич:Василье NP-PAT-VICH ; ! ""&lt;/code&gt;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-19" class="outline-3">
<h3 id="sec-1-19"><span class="section-number-3">1.19</span> (could be derived from anthroponyms automatically?)</h3>
</div>
<div id="outline-container-sec-1-20" class="outline-3">
<h3 id="sec-1-20"><span class="section-number-3">1.20</span> NP-TOP: toponyms (in particular, river names should go here too)</h3>
</div>
<div id="outline-container-sec-1-21" class="outline-3">
<h3 id="sec-1-21"><span class="section-number-3">1.21</span> NP-TOP-ASSR: former and future soviet socialistic republic names ending with СР: &lt;code&gt;Қырғыз% КСР:Қырғыз% КСР%{э%}%{й%} NP-TOP-ASSR ;&lt;/code&gt;</h3>
</div>
<div id="outline-container-sec-1-22" class="outline-3">
<h3 id="sec-1-22"><span class="section-number-3">1.22</span> NP-ORG: organization names</h3>
</div>
<div id="outline-container-sec-1-23" class="outline-3">
<h3 id="sec-1-23"><span class="section-number-3">1.23</span> NP-ORG-LAT: organization names written in Latin character. Example: Microsoft</h3>
</div>
<div id="outline-container-sec-1-24" class="outline-3">
<h3 id="sec-1-24"><span class="section-number-3">1.24</span> NP-AL: proper names not belonging to one of the above NP-* classes. Example: Восток</h3>
<div class="outline-text-3" id="text-1-24">
<p>
Verbs:
</p>
<ul class="org-ul">
<li>V-TV
</li>
<li>V-IV
</li>
<li>Vinfl-AUX
</li>
</ul>

<p>
Adjectives:
</p>

<ul class="org-ul">
<li>A1: adjectives which can be adverbialised and have a comparative form. Example: жақсы.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-25" class="outline-3">
<h3 id="sec-1-25"><span class="section-number-3">1.25</span> Test 1: can the word in question modify verb? "Жақсы оқиды" OK? A: yes.</h3>
</div>
<div id="outline-container-sec-1-26" class="outline-3">
<h3 id="sec-1-26"><span class="section-number-3">1.26</span> Test 2: has a comparative form? "Жақсырақ" OK? A: yes</h3>
</div>
<div id="outline-container-sec-1-27" class="outline-3">
<h3 id="sec-1-27"><span class="section-number-3">1.27</span> ==&gt; жақсы A1</h3>
<div class="outline-text-3" id="text-1-27">
<ul class="org-ul">
<li>A2: adjectives which cannot be adverbialized, but which do have the comparative form. Example: &lt;code&gt;лайық:лайық A2 ; ! ""&lt;/code&gt;
</li>

<li>A3: adjectives which can neither be adverbialized nor have comparative form
</li>

<li>A4: initially: adjectives like социал or (tat.) ''биологик'' = (kaz.) ''биологиялық'' which the author of this classification of adjectives thought to never substantivize, but have seen them substativized since then and thus considers deprecated.
</li>
</ul>

<p>
The whole purpose of introducing subclasses of adjectives was to avoid overgenerating forms which do not exist.
</p>

<p>
If you're unsure which adjective lexicon to select, pick A1.
</p>

<ul class="org-ul">
<li>A6:
</li>
</ul>

<p>
Adverbs:
</p>

<ul class="org-ul">
<li>ADV
</li>
<li>ADV-ITG
</li>
<li>ADV-WITH-KI
</li>
<li>ADV-WITH-KI-I
</li>
<li>ADV-LANG
</li>
</ul>

<p>
<i>Category:Tools</i>
<i>Category:Kazakh</i>
</p>

<hr  />

<p>
{{TOCD}}
</p>

<p>
<code>=Verbal noun or noun=</code>
</p>

<p>
<code>=Nominal compounds=</code>
</p>

<p>
When choosing between {{tag|attr}} and {{tag|nom}} in noun1-noun2 compounds, the choice basically depends on if noun2 is marked for possession. If it is marked for possession then you should chose {{tag|nom}}, if not, then choose {{tag|attr}}.
</p>

<ul class="org-ul">
<li>{{tag|attr}}:
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-28" class="outline-3">
<h3 id="sec-1-28"><span class="section-number-3">1.28</span> '''көрші''' елдер</h3>
<div class="outline-text-3" id="text-1-28">
<ul class="org-ul">
<li>{{tag|nom}}:
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-29" class="outline-3">
<h3 id="sec-1-29"><span class="section-number-3">1.29</span> '''əлем''' чемпионаты</h3>
<div class="outline-text-3" id="text-1-29">
<p>
However, there are cases when noun2 is marked for possession but noun1 is not its possessor, e.g. 
"жазба әдебиеті" in a phrase "қазақ жазба әдебиеті". 
&lt;pre&gt;
қазақ       жазба          әдебиеті
Kazakh.NOM  written.ATTR   literature.3SG
&lt;/pre&gt;
If we blindly applied the above rule for "жазба әдебиеті", then we would tag "жазба" as {{tag|nom}}, but actually "әдебиеті" is possessed by "қазақ", not by "жазба". 
Moreover, it is possible to drop "i" in "жазба әдебиеті", thus "жазба" is {{tag|attr}}.
</p>



<p>
&lt;!&#x2013; def. izafet: Иранның экономиясы&#x2013;&gt;
</p>

<p>
<code>=Specific words=</code>
</p>

<p>
<code>=</code>"-DA"<code>=</code>
</p>

<p>
The word "-DA" can be a conjunction or a postadverb:
</p>

<ul class="org-ul">
<li>&lt;code&gt;cnjcoo&lt;/code&gt; [joins two or more noun/verb phrases; it's conjoining two parallel things in the same phrase, as opposed to saying that it's adding one thing to something from before]
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-30" class="outline-3">
<h3 id="sec-1-30"><span class="section-number-3">1.30</span> Үстелде қалам '''да''', қарындаш '''та''', дәптер '''де''' жатыр.</h3>
</div>
<div id="outline-container-sec-1-31" class="outline-3">
<h3 id="sec-1-31"><span class="section-number-3">1.31</span> Абай әуелі ауылдағы Ғабитхан молдадан сауатын ашады '''да''', 10 жасқа толған соң 3 жыл Семейдегі Ахмет Риза медресесінде оқиды.</h3>
<div class="outline-text-3" id="text-1-31">
<ul class="org-ul">
<li>&lt;code&gt;postadverb&lt;/code&gt; [means 'also', 'even', or used for emphasis]
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-32" class="outline-3">
<h3 id="sec-1-32"><span class="section-number-3">1.32</span> Мен '''де''' барамын.</h3>
</div>
<div id="outline-container-sec-1-33" class="outline-3">
<h3 id="sec-1-33"><span class="section-number-3">1.33</span> Аузы қисық болса '''да''' байдын баласы сөйлесін.</h3>
<div class="outline-text-3" id="text-1-33">
<p>
<code>=</code>"бұл", "мынау", "осы", "мына", "анау", "ана", "сол"<code>=</code>
</p>

<p>
The word "бұл" (along with "мынау", "осы", "мына", "анау", "ана", "сол") can be either a determiner, modifying a noun phrase, or a pronoun, replacing a noun phrase.
</p>

<p>
&lt;code&gt;det.dem&lt;/code&gt;
</p>
</div>
</div>
<div id="outline-container-sec-1-34" class="outline-3">
<h3 id="sec-1-34"><span class="section-number-3">1.34</span> '''Мынау''' үй жаңа.</h3>
<div class="outline-text-3" id="text-1-34">
<ul class="org-ul">
<li>&lt;code&gt;prn&lt;/code&gt;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-35" class="outline-3">
<h3 id="sec-1-35"><span class="section-number-3">1.35</span> '''Мынау''' — терезе емес.</h3>
<div class="outline-text-3" id="text-1-35">
<p>
<i>Category:Kazakh</i>
</p>

<p>
The way to tell is whether it's part of the following noun phrase (det dem) or separate from it (prn)
</p>

<p>
<code>==Verbs in dictionary form==</code>
</p>

<p>
A verb in a dictionary form (gerund) can sometimes be a noun.
</p>
<ul class="org-ul">
<li>&lt;code&gt;ger&lt;/code&gt;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-36" class="outline-3">
<h3 id="sec-1-36"><span class="section-number-3">1.36</span> Кітап '''оқу''' адамдарды ақылдырақ етеді.</h3>
<div class="outline-text-3" id="text-1-36">
<ul class="org-ul">
<li>&lt;code&gt;n&lt;/code&gt;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-37" class="outline-3">
<h3 id="sec-1-37"><span class="section-number-3">1.37</span> '''Оқу''' басталды.</h3>
<div class="outline-text-3" id="text-1-37">
<p>
With gerunds you often get embedded arguments, like "кітап" in the example above.
</p>

<p>
If there is an adjective or determiner preceding: noun.
</p>

<p>
Some cases are ambiguous: Балалардың '''оқу'''ы жақсы болды.  Here, it's unclear whether бала is the subject of a verbal noun or the possessor of a noun.  In cases like this, the context can sometimes provide some intuition; e.g., in "Балалардың '''оқу'''ы басталды.", оқу seems more like a noun and less like a gerund.  In such ambiguous cases, if you have an intuition, go with that.  If not, go with verbal noun (the reason being that we would need more things in our lexicon, and also that these "noun" are derived from verbs anyway).
</p>

<p>
<code>==Perfect participle or Verbal adverb==</code>
</p>

<p>
Perfect participle (&lt;code&gt;prc<sub>perf</sub>&lt;/code&gt;) if there is an auxiliary following, otherwise verbal adverb (&lt;code&gt;gna<sub>perf</sub>&lt;/code&gt;)
</p>
<ul class="org-ul">
<li>&lt;code&gt;prc<sub>perf</sub>&lt;/code&gt;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-38" class="outline-3">
<h3 id="sec-1-38"><span class="section-number-3">1.38</span> Ол кәзір '''ұйықтап''' жатыр.</h3>
<div class="outline-text-3" id="text-1-38">
<ul class="org-ul">
<li>&lt;code&gt;gna<sub>perf</sub>&lt;/code&gt;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-39" class="outline-3">
<h3 id="sec-1-39"><span class="section-number-3">1.39</span> Мектепті '''бітіріп''', университетке түстім.</h3>
</div>
<div id="outline-container-sec-1-40" class="outline-3">
<h3 id="sec-1-40"><span class="section-number-3">1.40</span> Орталық Азиядан арий тайпалары '''келіп''' қоныстанды.</h3>
<div class="outline-text-3" id="text-1-40">
<p>
There is also other evidence that ''келіп'' in the example above is a verbal adverb: In particular, you can put arguments/adjuncts of ''қоныстанды'' between ''келіп'' and ''қоныстанды'', like "Орталық Азиядан арий тайпалары келіп бұл аймақта қоныстанды." In this case the two verbs function
as separate predicates, which participle+auxiliary constructions don't do.
</p>

<p>
<code>=Futher reading=</code>
</p>

<p>
<a href="http://web.stanford.edu/~lelia/krejci_glass.pdf">http://web.stanford.edu/~lelia/krejci_glass.pdf</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Илнар Сәлимҗанов</p>
<p class="date">Created: 2018-09-13 Thu 04:28</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
